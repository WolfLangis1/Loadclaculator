import { describe, it, expect, beforeEach } from 'vitest';
import { SLDService } from '../../services/sldService';
import type { LoadState, SLDDiagram } from '../../types';

describe('SLDService', () => {
  let mockLoadState: LoadState;
  let mockProjectInfo: any;

  beforeEach(() => {
    mockLoadState = {
      projectInfo: {
        customerName: 'Test Customer',
        propertyAddress: '123 Test St',
        projectDescription: 'Test Project',
        jurisdiction: 'Test City',
        permitNumber: 'P2024001'
      },
      generalLoads: [],
      hvacLoads: [],
      evseLoads: [
        {
          id: 'evse1',
          name: 'Tesla Wall Connector',
          quantity: 1,
          amps: 48,
          volts: 240,
          va: 11520,
          notes: 'Level 2 EVSE'
        }
      ],
      solarBatteryLoads: [
        {
          id: 'solar1',
          type: 'solar',
          name: 'Solar Array',
          quantity: 1,
          kw: 10,
          notes: 'Rooftop solar'
        },
        {
          id: 'battery1',
          type: 'battery',
          name: 'Battery Storage',
          quantity: 1,
          kw: 13.5,
          notes: 'Tesla Powerwall'
        }
      ]
    };

    mockProjectInfo = {
      id: 'test-project',
      customerName: 'Test Customer',
      codeYear: '2023',
      jurisdiction: 'Test City'
    };
  });

  describe('generateFromLoadData', () => {
    it('should generate a complete SLD diagram from load data', () => {
      const diagram = SLDService.generateFromLoadData(mockLoadState, mockProjectInfo);

      expect(diagram).toBeDefined();
      expect(diagram.id).toMatch(/^sld_/);
      expect(diagram.name).toBe('Test Customer - Single Line Diagram');
      expect(diagram.systemType).toBe('grid_tied_with_battery');
      expect(diagram.necCodeYear).toBe('2023');
      expect(diagram.autoGenerated).toBe(true);
    });

    it('should create main panel component', () => {
      const diagram = SLDService.generateFromLoadData(mockLoadState, mockProjectInfo);
      const mainPanel = diagram.components.find(c => c.type === 'main_panel');

      expect(mainPanel).toBeDefined();
      expect(mainPanel?.name).toBe('Main Service Panel');
      expect(mainPanel?.necLabels).toContain('WARNING: DISCONNECT ENERGIZED BY TWO SOURCES');
    });

    it('should create grid connection component', () => {
      const diagram = SLDService.generateFromLoadData(mockLoadState, mockProjectInfo);
      const grid = diagram.components.find(c => c.type === 'grid');

      expect(grid).toBeDefined();
      expect(grid?.name).toBe('Utility Grid');
    });

    it('should create grounding electrode component', () => {
      const diagram = SLDService.generateFromLoadData(mockLoadState, mockProjectInfo);
      const grounding = diagram.components.find(c => c.type === 'grounding_electrode');

      expect(grounding).toBeDefined();
      expect(grounding?.name).toBe('Grounding Electrode');
    });

    it('should create solar components when solar loads exist', () => {
      const diagram = SLDService.generateFromLoadData(mockLoadState, mockProjectInfo);
      
      const pvArray = diagram.components.find(c => c.type === 'pv_array');
      const dcDisconnect = diagram.components.find(c => c.type === 'dc_disconnect');
      const inverter = diagram.components.find(c => c.type === 'inverter');
      const acDisconnect = diagram.components.find(c => c.type === 'ac_disconnect');

      expect(pvArray).toBeDefined();
      expect(dcDisconnect).toBeDefined();
      expect(inverter).toBeDefined();
      expect(acDisconnect).toBeDefined();

      // Verify PV array specifications
      const pvArrayTyped = pvArray as any;
      expect(pvArrayTyped.numStrings).toBeGreaterThan(0);
      expect(pvArrayTyped.modulesPerString).toBe(12);
      expect(pvArrayTyped.moduleWattage).toBe(400);
    });

    it('should create battery components when battery loads exist', () => {
      const diagram = SLDService.generateFromLoadData(mockLoadState, mockProjectInfo);
      const battery = diagram.components.find(c => c.type === 'battery');

      expect(battery).toBeDefined();
      expect(battery?.name).toBe('Battery Storage');
      
      const batteryTyped = battery as any;
      expect(batteryTyped.capacityKWh).toBe(54); // 13.5kW * 4 hours
      expect(batteryTyped.powerKW).toBe(13.5);
      expect(batteryTyped.coupling).toBe('ac');
    });

    it('should create EVSE components when EVSE loads exist', () => {
      const diagram = SLDService.generateFromLoadData(mockLoadState, mockProjectInfo);
      const evse = diagram.components.find(c => c.type === 'evse_charger');

      expect(evse).toBeDefined();
      expect(evse?.name).toBe('EV Charger');
      
      const evseTyped = evse as any;
      expect(evseTyped.current).toBe(48);
      expect(evseTyped.voltage).toBe(240);
      expect(evseTyped.level).toBe(2);
    });

    it('should generate connections between components', () => {
      const diagram = SLDService.generateFromLoadData(mockLoadState, mockProjectInfo);
      
      expect(diagram.connections.length).toBeGreaterThan(0);
      
      // Verify DC connections from PV array to DC disconnect
      const dcConnections = diagram.connections.filter(c => c.wireType === 'dc');
      expect(dcConnections.length).toBeGreaterThan(0);
      
      // Verify AC connections
      const acConnections = diagram.connections.filter(c => c.wireType === 'ac');
      expect(acConnections.length).toBeGreaterThan(0);
      
      // Verify grounding connections
      const groundConnections = diagram.connections.filter(c => c.wireType === 'ground');
      expect(groundConnections.length).toBeGreaterThan(0);
    });

    it('should add NEC-required labels', () => {
      const diagram = SLDService.generateFromLoadData(mockLoadState, mockProjectInfo);
      
      expect(diagram.labels.length).toBeGreaterThan(0);
      expect(diagram.requiredLabels.length).toBeGreaterThan(0);
      
      // Check for specific NEC labels
      const necLabels = diagram.labels.filter(l => l.necRequired);
      expect(necLabels.length).toBeGreaterThan(0);
      
      // Verify label content
      const disconnectLabel = necLabels.find(l => l.text.includes('PV SYSTEM DISCONNECT'));
      expect(disconnectLabel).toBeDefined();
    });

    it('should validate NEC compliance', () => {
      const diagram = SLDService.generateFromLoadData(mockLoadState, mockProjectInfo);
      
      // Should be compliant when all required components are present
      expect(diagram.necCompliant).toBe(true);
      expect(diagram.necViolations.length).toBe(0);
    });

    it('should auto-layout components when enabled', () => {
      const config = {
        style: 'professional' as const,
        includeSpecifications: true,
        includeNECLabels: true,
        autoLayout: true,
        componentSpacing: 150,
        lineStyle: 'solid' as const,
        showGrounding: true,
        showConduitSizing: false,
        colorCoding: false
      };
      
      const diagram = SLDService.generateFromLoadData(mockLoadState, mockProjectInfo, config);
      
      // Components should have logical positioning
      const pvArray = diagram.components.find(c => c.type === 'pv_array');
      const mainPanel = diagram.components.find(c => c.type === 'main_panel');
      const grid = diagram.components.find(c => c.type === 'grid');
      
      expect(pvArray?.position.x).toBeLessThan(mainPanel?.position.x || 0);
      expect(mainPanel?.position.x).toBeLessThan(grid?.position.x || 0);
    });

    it('should determine correct system type', () => {
      // Grid-tied with battery
      let diagram = SLDService.generateFromLoadData(mockLoadState, mockProjectInfo);
      expect(diagram.systemType).toBe('grid_tied_with_battery');
      
      // Grid-tied only (no battery)
      const solarOnlyState = {
        ...mockLoadState,
        solarBatteryLoads: mockLoadState.solarBatteryLoads.filter(l => l.type === 'solar')
      };
      diagram = SLDService.generateFromLoadData(solarOnlyState, mockProjectInfo);
      expect(diagram.systemType).toBe('grid_tied');
      
      // Grid-tied default (no solar or battery)
      const noRenewableState = {
        ...mockLoadState,
        solarBatteryLoads: []
      };
      diagram = SLDService.generateFromLoadData(noRenewableState, mockProjectInfo);
      expect(diagram.systemType).toBe('grid_tied');
    });
  });

  describe('Component Creation', () => {
    it('should create valid component IDs', () => {
      const diagram = SLDService.generateFromLoadData(mockLoadState, mockProjectInfo);
      
      diagram.components.forEach(component => {
        expect(component.id).toMatch(/^sld_\d+_[a-z0-9]+$/);
        expect(component.id.length).toBeGreaterThan(10);
      });
    });

    it('should set proper component specifications', () => {
      const diagram = SLDService.generateFromLoadData(mockLoadState, mockProjectInfo);
      
      const inverter = diagram.components.find(c => c.type === 'inverter') as any;
      expect(inverter?.acOutputKW).toBe(10);
      expect(inverter?.efficiency).toBe(0.97);
      expect(inverter?.mpptChannels).toBe(2);
      
      const evse = diagram.components.find(c => c.type === 'evse_charger') as any;
      expect(evse?.powerKW).toBe(11.52); // 11520VA / 1000
      expect(evse?.level).toBe(2);
      expect(evse?.dedicatedCircuit).toBe(true);
    });
  });

  describe('Error Handling', () => {
    it('should handle missing load data gracefully', () => {
      const emptyLoadState: LoadState = {
        projectInfo: mockLoadState.projectInfo,
        generalLoads: [],
        hvacLoads: [],
        evseLoads: [],
        solarBatteryLoads: []
      };
      
      const diagram = SLDService.generateFromLoadData(emptyLoadState, mockProjectInfo);
      
      expect(diagram).toBeDefined();
      expect(diagram.components.length).toBeGreaterThanOrEqual(3); // At least main panel, grid, and grounding
    });

    it('should handle missing project info gracefully', () => {
      const minimalProjectInfo = { id: 'test' };
      
      const diagram = SLDService.generateFromLoadData(mockLoadState, minimalProjectInfo);
      
      expect(diagram).toBeDefined();
      expect(diagram.name).toContain('Unnamed');
      expect(diagram.ahj).toBe('Local AHJ');
    });
  });

  describe('NEC Compliance Validation', () => {
    it('should detect missing DC disconnect violation', () => {
      // Create a diagram and manually remove DC disconnect
      const diagram = SLDService.generateFromLoadData(mockLoadState, mockProjectInfo);
      diagram.components = diagram.components.filter(c => c.type !== 'dc_disconnect');
      
      // Re-validate
      const violations: string[] = [];
      const hasPVArray = diagram.components.some(c => c.type === 'pv_array');
      const hasDCDisconnect = diagram.components.some(c => c.type === 'dc_disconnect');
      
      if (hasPVArray && !hasDCDisconnect) {
        violations.push('PV systems require DC disconnect per NEC 690.13');
      }
      
      expect(violations.length).toBeGreaterThan(0);
      expect(violations[0]).toContain('DC disconnect');
    });

    it('should detect missing grounding violation', () => {
      const diagram = SLDService.generateFromLoadData(mockLoadState, mockProjectInfo);
      diagram.components = diagram.components.filter(c => c.type !== 'grounding_electrode');
      
      const violations: string[] = [];
      const hasGrounding = diagram.components.some(c => c.type === 'grounding_electrode');
      
      if (!hasGrounding) {
        violations.push('System requires grounding electrode per NEC 250.52');
      }
      
      expect(violations.length).toBeGreaterThan(0);
      expect(violations[0]).toContain('grounding electrode');
    });
  });
});