import { describe, it, expect, beforeEach, vi } from 'vitest';
import { SLDIntegrationService } from '../../services/sldIntegrationService';
import type { SLDDiagram, SLDComponent, SLDConnection } from '../../types/sld';

// Mock the external services
vi.mock('../../services/sldWireService', () => ({
  SLDWireService: {
    calculateWireSizing: vi.fn().mockReturnValue({
      conductorSize: '12 AWG',
      voltageDropPercent: 1.5,
      ampacity: 20,
      derating: 1.0,
      conduitFill: 0.4
    })
  }
}));

vi.mock('../../services/sldNECEngine', () => ({
  SLDNECEngine: {
    validateDiagram: vi.fn().mockReturnValue({
      overallCompliant: true,
      summary: {
        errors: 0,
        warnings: 1,
        autoFixable: 0
      },
      recommendations: ['Consider adding equipment labels']
    }),
    autoFixViolations: vi.fn().mockImplementation((diagram) => diagram)
  }
}));

vi.mock('../../services/sldLoadFlowService', () => ({
  SLDLoadFlowService: {
    analyzeCircuit: vi.fn().mockReturnValue({
      efficiency: 96.5,
      criticalPaths: [],
      circuitPaths: [{ id: 'path1', components: ['comp1', 'comp2'] }],
      recommendations: []
    }),
    optimizeLayout: vi.fn().mockImplementation((diagram) => diagram)
  }
}));

vi.mock('../../services/sldExportService', () => ({
  SLDExportService: {
    exportToPDF: vi.fn().mockResolvedValue({ success: true, data: 'pdf-data' }),
    exportToSVG: vi.fn().mockResolvedValue({ success: true, data: 'svg-data' }),
    exportToPNG: vi.fn().mockResolvedValue({ success: true, data: 'png-data' }),
    exportToJSON: vi.fn().mockReturnValue({ success: true, data: 'json-data' }),
    exportToCAD: vi.fn().mockResolvedValue({ success: true, data: 'cad-data' }),
    generatePermitPackage: vi.fn().mockResolvedValue({ success: true, data: 'permit-data' })
  }
}));

vi.mock('../../services/sldCollaborationService', () => ({
  collaborationService: {
    createSession: vi.fn().mockReturnValue({
      id: 'session1',
      diagramId: 'diagram1',
      participants: [],
      isActive: true
    }),
    joinSession: vi.fn().mockReturnValue({
      id: 'session1',
      diagramId: 'diagram1',
      participants: [],
      isActive: true
    }),
    cleanup: vi.fn()
  }
}));

describe('SLDIntegrationService', () => {
  let service: SLDIntegrationService;
  let mockDiagram: SLDDiagram;
  let mockUser: any;

  beforeEach(() => {
    service = SLDIntegrationService.getInstance();
    
    mockDiagram = {
      id: 'test-diagram',
      projectId: 'test-project',
      name: 'Test Diagram',
      created: new Date(),
      lastModified: new Date(),
      version: '1.0',
      necCodeYear: '2023',
      systemType: 'grid_tied_with_battery',
      components: [
        {
          id: 'comp1',
          type: 'main_panel',
          name: 'Main Panel',
          position: { x: 100, y: 100 },
          size: { width: 80, height: 60 },
          rotation: 0,
          labels: [],
          necLabels: [],
          specifications: {}
        } as SLDComponent,
        {
          id: 'comp2',
          type: 'grid',
          name: 'Grid',
          position: { x: 200, y: 100 },
          size: { width: 60, height: 40 },
          rotation: 0,
          labels: [],
          necLabels: [],
          specifications: {}
        } as SLDComponent
      ],
      connections: [
        {
          id: 'conn1',
          fromComponentId: 'comp1',
          toComponentId: 'comp2',
          fromPort: 'output',
          toPort: 'input',
          wireType: 'ac'
        }
      ],
      labels: [],
      canvasSize: { width: 1200, height: 800 },
      backgroundColor: '#ffffff',
      gridEnabled: true,
      snapToGrid: true,
      autoGenerated: false,
      necCompliant: true,
      necViolations: [],
      requiredLabels: [],
      designedBy: 'Test Designer',
      ahj: 'Test AHJ'
    };

    mockUser = {
      id: 'user1',
      name: 'Test User',
      email: 'test@example.com',
      color: '#3b82f6',
      isOnline: true,
      lastActivity: new Date()
    };
  });

  describe('Initialization', () => {
    it('should be a singleton', () => {
      const service2 = SLDIntegrationService.getInstance();
      expect(service).toBe(service2);
    });

    it('should initialize with diagram and user', () => {
      service.initialize(mockDiagram, mockUser);
      
      expect(service.getCurrentUser()).toBe(mockUser);
      expect(service.getCommandManager()).toBeDefined();
    });
  });

  describe('Comprehensive Analysis', () => {
    it('should perform comprehensive analysis successfully', async () => {
      const analysis = await service.performComprehensiveAnalysis(mockDiagram);
      
      expect(analysis).toBeDefined();
      expect(analysis.diagram).toBe(mockDiagram);
      expect(analysis.wireAnalysis).toBeDefined();
      expect(analysis.necCompliance).toBeDefined();
      expect(analysis.loadFlow).toBeDefined();
      expect(analysis.recommendations).toBeDefined();
      expect(analysis.overallScore).toBeGreaterThanOrEqual(0);
      expect(analysis.overallScore).toBeLessThanOrEqual(100);
    });

    it('should calculate overall score correctly', async () => {
      const analysis = await service.performComprehensiveAnalysis(mockDiagram);
      
      // Score should be high with good compliance and efficiency
      expect(analysis.overallScore).toBeGreaterThan(90);
    });

    it('should generate recommendations', async () => {
      const analysis = await service.performComprehensiveAnalysis(mockDiagram);
      
      expect(Array.isArray(analysis.recommendations)).toBe(true);
      // Should have at least one recommendation from mocked NEC compliance
      expect(analysis.recommendations.length).toBeGreaterThan(0);
    });

    it('should handle analysis errors gracefully', async () => {
      const invalidDiagram = { ...mockDiagram, connections: [] as any };
      
      try {
        await service.performComprehensiveAnalysis(invalidDiagram);
      } catch (error) {
        expect(error).toBeInstanceOf(Error);
        expect((error as Error).message).toContain('analysis failed');
      }
    });
  });

  describe('Auto Optimization', () => {
    it('should auto-optimize diagram', async () => {
      const optimizedDiagram = await service.autoOptimizeDiagram(mockDiagram);
      
      expect(optimizedDiagram).toBeDefined();
      expect(optimizedDiagram.id).toBe(mockDiagram.id);
      // Should have same or more components after optimization
      expect(optimizedDiagram.components.length).toBeGreaterThanOrEqual(mockDiagram.components.length);
    });

    it('should apply wire sizing optimizations', async () => {
      // Create diagram with high voltage drop connection
      const highDropDiagram = {
        ...mockDiagram,
        connections: [
          {
            id: 'conn1',
            fromComponentId: 'comp1',
            toComponentId: 'comp2',
            fromPort: 'output',
            toPort: 'input',
            wireType: 'ac' as const,
            label: 'Test Connection'
          }
        ]
      };

      // Mock high voltage drop
      const { SLDWireService } = await import('../../services/sldWireService');
      vi.mocked(SLDWireService.calculateWireSizing).mockReturnValue({
        conductorSize: '12 AWG',
        voltageDropPercent: 4.5, // High voltage drop
        ampacity: 20,
        derating: 1.0,
        conduitFill: 0.4
      });

      const optimizedDiagram = await service.autoOptimizeDiagram(highDropDiagram);
      
      // Should add optimization note to connection
      const connection = optimizedDiagram.connections[0];
      expect(connection.label).toContain('OPTIMIZE');
    });
  });

  describe('Permit Package Generation', () => {
    it('should generate permit package successfully', async () => {
      const result = await service.generatePermitPackage(mockDiagram);
      
      expect(result.success).toBe(true);
      expect(result.data).toBeDefined();
      expect(result.timestamp).toBeInstanceOf(Date);
    });

    it('should handle permit package generation errors', async () => {
      // Mock export service to fail
      const { SLDExportService } = await import('../../services/sldExportService');
      vi.mocked(SLDExportService.generatePermitPackage).mockRejectedValue(new Error('Export failed'));
      
      const result = await service.generatePermitPackage(mockDiagram);
      
      expect(result.success).toBe(false);
      expect(result.error).toContain('Export failed');
    });
  });

  describe('Collaboration', () => {
    it('should start collaboration session', () => {
      const session = service.startCollaboration(mockDiagram, mockUser);
      
      expect(session).toBeDefined();
      expect(session.id).toBe('session1');
      expect(session.diagramId).toBe(mockDiagram.id);
    });

    it('should join collaboration session', () => {
      const session = service.joinCollaboration('session1', mockUser);
      
      expect(session).toBeDefined();
      expect(session.id).toBe('session1');
    });
  });

  describe('Export Functionality', () => {
    it('should export to PDF', async () => {
      const result = await service.exportDiagram(mockDiagram, 'pdf');
      
      expect(result.success).toBe(true);
      expect(result.data).toBe('pdf-data');
    });

    it('should export to SVG', async () => {
      const result = await service.exportDiagram(mockDiagram, 'svg');
      
      expect(result.success).toBe(true);
      expect(result.data).toBe('svg-data');
    });

    it('should export to PNG', async () => {
      const result = await service.exportDiagram(mockDiagram, 'png');
      
      expect(result.success).toBe(true);
      expect(result.data).toBe('png-data');
    });

    it('should export to JSON', async () => {
      const result = await service.exportDiagram(mockDiagram, 'json');
      
      expect(result.success).toBe(true);
      expect(result.data).toBe('json-data');
    });

    it('should export to CAD', async () => {
      const result = await service.exportDiagram(mockDiagram, 'dxf');
      
      expect(result.success).toBe(true);
      expect(result.data).toBe('cad-data');
    });

    it('should handle unsupported export format', async () => {
      const result = await service.exportDiagram(mockDiagram, 'invalid' as any);
      
      expect(result.success).toBe(false);
      expect(result.error).toContain('Unsupported export format');
    });

    it('should handle export errors', async () => {
      // Mock export service to fail
      const { SLDExportService } = await import('../../services/sldExportService');
      vi.mocked(SLDExportService.exportToPDF).mockRejectedValue(new Error('Export failed'));
      
      const result = await service.exportDiagram(mockDiagram, 'pdf');
      
      expect(result.success).toBe(false);
      expect(result.error).toContain('Export failed');
    });
  });

  describe('Validation', () => {
    it('should validate diagram and return issues', () => {
      const issues = service.validateDiagram(mockDiagram);
      
      expect(Array.isArray(issues)).toBe(true);
      // Should pass basic validation
      expect(issues.length).toBe(0);
    });

    it('should detect empty diagram issues', () => {
      const emptyDiagram = {
        ...mockDiagram,
        components: [],
        connections: []
      };
      
      const issues = service.validateDiagram(emptyDiagram);
      
      expect(issues.length).toBeGreaterThan(0);
      expect(issues.some(issue => issue.message.includes('No components'))).toBe(true);
      expect(issues.some(issue => issue.message.includes('No connections'))).toBe(true);
    });

    it('should detect component naming issues', () => {
      const invalidDiagram = {
        ...mockDiagram,
        components: [
          {
            ...mockDiagram.components[0],
            name: '' // Empty name
          }
        ]
      };
      
      const issues = service.validateDiagram(invalidDiagram);
      
      expect(issues.some(issue => issue.message.includes('must have a name'))).toBe(true);
    });

    it('should detect invalid connections', () => {
      const invalidDiagram = {
        ...mockDiagram,
        connections: [
          {
            id: 'invalid-conn',
            fromComponentId: 'non-existent',
            toComponentId: 'also-non-existent',
            fromPort: 'output',
            toPort: 'input',
            wireType: 'ac' as const
          }
        ]
      };
      
      const issues = service.validateDiagram(invalidDiagram);
      
      expect(issues.some(issue => issue.message.includes('non-existent component'))).toBe(true);
    });
  });

  describe('Project Statistics', () => {
    it('should calculate project statistics', () => {
      const stats = service.getProjectStatistics(mockDiagram);
      
      expect(stats.components).toBe(2);
      expect(stats.connections).toBe(1);
      expect(stats.systemType).toBe('grid_tied_with_battery');
      expect(stats.complexity).toBe('low');
      expect(stats.estimatedCost).toBeGreaterThan(0);
    });

    it('should determine complexity levels correctly', () => {
      // Low complexity
      let stats = service.getProjectStatistics(mockDiagram);
      expect(stats.complexity).toBe('low');
      
      // Medium complexity
      const mediumDiagram = {
        ...mockDiagram,
        components: new Array(15).fill(null).map((_, i) => ({
          ...mockDiagram.components[0],
          id: `comp${i}`
        }))
      };
      stats = service.getProjectStatistics(mediumDiagram);
      expect(stats.complexity).toBe('medium');
      
      // High complexity
      const highDiagram = {
        ...mockDiagram,
        components: new Array(25).fill(null).map((_, i) => ({
          ...mockDiagram.components[0],
          id: `comp${i}`
        }))
      };
      stats = service.getProjectStatistics(highDiagram);
      expect(stats.complexity).toBe('high');
    });
  });

  describe('Command Management', () => {
    it('should execute commands when initialized', () => {
      service.initialize(mockDiagram);
      
      const mockCommand = {
        id: 'test-command',
        type: 'add_component' as const,
        timestamp: new Date(),
        execute: vi.fn(),
        undo: vi.fn(),
        getData: vi.fn().mockReturnValue({})
      };
      
      expect(() => service.executeCommand(mockCommand)).not.toThrow();
    });

    it('should throw error when executing commands without initialization', () => {
      const cleanService = new (SLDIntegrationService as any)();
      
      const mockCommand = {
        id: 'test-command',
        type: 'add_component' as const,
        timestamp: new Date(),
        execute: vi.fn(),
        undo: vi.fn(),
        getData: vi.fn().mockReturnValue({})
      };
      
      expect(() => cleanService.executeCommand(mockCommand)).toThrow('not initialized');
    });
  });

  describe('Cleanup', () => {
    it('should cleanup resources', () => {
      service.initialize(mockDiagram, mockUser);
      
      expect(service.getCurrentUser()).toBe(mockUser);
      expect(service.getCommandManager()).toBeDefined();
      
      service.cleanup();
      
      expect(service.getCurrentUser()).toBe(null);
      expect(service.getCommandManager()).toBe(null);
    });
  });
});