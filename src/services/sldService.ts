// Single Line Diagram Service
// Handles diagram generation, component management, and NEC compliance

import type { 
  SLDDiagram, 
  SLDComponent, 
  SLDConnection, 
  SLDLabel,
  SLDGenerationConfig,
  NECRequirement,
  SLDPVArray,
  SLDInverter,
  SLDDisconnect,
  SLDBattery,
  SLDMainPanel,
  SLDEVSECharger,
  SLDGrid,
  SLDGroundingElectrode
} from '../types/sld';
import type { LoadState } from '../types';

export class SLDService {
  private static necRequirements: NECRequirement[] = [
    {
      article: '690.13(B)',
      section: 'Disconnect Labeling',
      description: 'PV system disconnects shall be permanently marked',
      labelText: 'PV SYSTEM DISCONNECT',
      required: true,
      componentTypes: ['dc_disconnect', 'ac_disconnect']
    },
    {
      article: '690.55',
      section: 'Battery System Marking',
      description: 'Battery systems shall be marked with maximum voltage and polarity',
      labelText: 'WARNING: BATTERY SYSTEM - MAX VOLTAGE: {voltage}V',
      required: true,
      componentTypes: ['battery']
    },
    {
      article: '705.12(D)(4)',
      section: 'Multiple Source Warning',
      description: 'Service equipment fed from multiple sources requires warning label',
      labelText: 'WARNING: DISCONNECT ENERGIZED BY TWO SOURCES',
      required: true,
      componentTypes: ['main_panel']
    },
    {
      article: '690.64(B)',
      section: 'Directory Labels',
      description: 'Directory listing all sources shall be posted at service equipment',
      labelText: 'ELECTRICAL SOURCES:\n1. UTILITY\n2. SOLAR PV SYSTEM\n3. BATTERY STORAGE',
      required: true,
      componentTypes: ['main_panel']
    },
    {
      article: '625.43',
      section: 'EVSE Disconnect',
      description: 'EVSE equipment shall have disconnect means',
      labelText: 'ELECTRIC VEHICLE CHARGING DISCONNECT',
      required: true,
      componentTypes: ['evse_charger']
    }
  ];

  /**
   * Generate SLD from existing load calculator data
   */
  static generateFromLoadData(
    loadState: LoadState,
    projectInfo: any,
    config: SLDGenerationConfig = this.getDefaultConfig()
  ): SLDDiagram {
    const diagram: SLDDiagram = {
      id: this.generateId(),
      projectId: projectInfo.id || this.generateId(),
      name: `${projectInfo.customerName || 'Unnamed'} - Single Line Diagram`,
      created: new Date(),
      lastModified: new Date(),
      version: '1.0',
      necCodeYear: projectInfo.codeYear || '2023',
      systemType: this.determineSystemType(loadState),
      components: [],
      connections: [],
      labels: [],
      canvasSize: { width: 1200, height: 800 },
      backgroundColor: '#ffffff',
      gridEnabled: true,
      snapToGrid: true,
      autoGenerated: true,
      necCompliant: false,
      necViolations: [],
      requiredLabels: [],
      designedBy: projectInfo.customerName || 'Auto-Generated',
      ahj: projectInfo.jurisdiction || 'Local AHJ'
    };

    // Generate components based on load data
    this.generateComponents(diagram, loadState, config);
    
    // Generate connections between components
    this.generateConnections(diagram);
    
    // Add NEC-required labels
    this.addNECLabels(diagram);
    
    // Validate NEC compliance
    this.validateNECCompliance(diagram);
    
    // Auto-layout components
    if (config.autoLayout) {
      this.autoLayoutComponents(diagram);
    }

    return diagram;
  }

  /**
   * Generate components from load calculator data
   */
  private static generateComponents(
    diagram: SLDDiagram, 
    loadState: LoadState, 
    config: SLDGenerationConfig
  ): void {
    let yPosition = 100;
    const spacing = config.componentSpacing || 150;

    // Always add main service panel
    const mainPanel = this.createMainPanel(yPosition);
    diagram.components.push(mainPanel);
    yPosition += spacing;

    // Add grid connection
    const grid = this.createGrid(yPosition);
    diagram.components.push(grid);
    yPosition += spacing;

    // Add grounding electrode
    const grounding = this.createGroundingElectrode(yPosition);
    diagram.components.push(grounding);
    yPosition += spacing;

    // Add solar components if solar loads exist
    const solarLoads = loadState.solarBatteryLoads.filter(load => 
      load.type === 'solar' && load.quantity > 0
    );
    
    if (solarLoads.length > 0) {
      solarLoads.forEach((solarLoad, index) => {
        // PV Array
        const pvArray = this.createPVArray(solarLoad, yPosition + (index * spacing));
        diagram.components.push(pvArray);

        // DC Disconnect
        const dcDisconnect = this.createDCDisconnect(yPosition + (index * spacing) + 50);
        diagram.components.push(dcDisconnect);

        // Inverter
        const inverter = this.createInverter(solarLoad, yPosition + (index * spacing) + 100);
        diagram.components.push(inverter);

        // AC Disconnect
        const acDisconnect = this.createACDisconnect(yPosition + (index * spacing) + 150);
        diagram.components.push(acDisconnect);
      });
      
      yPosition += solarLoads.length * spacing + 200;
    }

    // Add battery components if battery loads exist
    const batteryLoads = loadState.solarBatteryLoads.filter(load => 
      load.type === 'battery' && load.quantity > 0
    );
    
    if (batteryLoads.length > 0) {
      batteryLoads.forEach((batteryLoad, index) => {
        const battery = this.createBattery(batteryLoad, yPosition + (index * spacing));
        diagram.components.push(battery);
      });
      
      yPosition += batteryLoads.length * spacing;
    }

    // Add EVSE components if EVSE loads exist
    const evseLoads = loadState.evseLoads.filter(load => load.quantity > 0);
    
    if (evseLoads.length > 0) {
      evseLoads.forEach((evseLoad, index) => {
        const evse = this.createEVSECharger(evseLoad, yPosition + (index * spacing));
        diagram.components.push(evse);
      });
    }
  }

  /**
   * Create main service panel component
   */
  private static createMainPanel(yPosition: number): SLDMainPanel {
    return {
      id: this.generateId(),
      type: 'main_panel',
      name: 'Main Service Panel',
      position: { x: 600, y: yPosition },
      size: { width: 120, height: 80 },
      rotation: 0,
      labels: [],
      necLabels: ['WARNING: DISCONNECT ENERGIZED BY TWO SOURCES'],
      specifications: {},
      rating: 200, // Default, should come from load calculator
      busRating: 200,
      voltage: 240,
      phase: 1,
      manufacturer: 'Square D',
      model: 'QO',
      meterLocation: 'external',
      groundingElectrode: true
    };
  }

  /**
   * Create grid connection component
   */
  private static createGrid(yPosition: number): SLDGrid {
    return {
      id: this.generateId(),
      type: 'grid',
      name: 'Utility Grid',
      position: { x: 800, y: yPosition },
      size: { width: 80, height: 60 },
      rotation: 0,
      labels: [],
      necLabels: [],
      specifications: {},
      utilityName: 'Local Utility',
      serviceVoltage: 240,
      serviceType: 'overhead',
      meterType: 'smart',
      netMetering: true
    };
  }

  /**
   * Create PV array component
   */
  private static createPVArray(solarLoad: any, yPosition: number): SLDPVArray {
    const moduleWattage = 400; // Default module wattage
    const numModules = Math.ceil((solarLoad.kw * 1000) / moduleWattage);
    
    return {
      id: this.generateId(),
      type: 'pv_array',
      name: 'PV Array',
      position: { x: 100, y: yPosition },
      size: { width: 100, height: 60 },
      rotation: 0,
      labels: [],
      necLabels: [`${numModules} MODULES @ ${moduleWattage}W EACH`],
      specifications: {
        totalPower: solarLoad.kw * 1000,
        modules: numModules
      },
      numStrings: Math.ceil(numModules / 12), // Assume 12 modules per string
      modulesPerString: 12,
      moduleWattage,
      moduleVoltage: 40,
      moduleCurrent: 10,
      arrayVoltage: 480, // 12 modules * 40V
      arrayCurrent: Math.ceil(numModules / 12) * 10,
      manufacturer: 'Generic',
      model: 'Solar Module',
      location: 'roof'
    };
  }

  /**
   * Create DC disconnect component
   */
  private static createDCDisconnect(yPosition: number): SLDDisconnect {
    return {
      id: this.generateId(),
      type: 'dc_disconnect',
      name: 'PV DC Disconnect',
      position: { x: 250, y: yPosition },
      size: { width: 60, height: 40 },
      rotation: 0,
      labels: [],
      necLabels: ['PV SYSTEM DISCONNECT', 'MAX VOLTAGE: 600V DC'],
      specifications: {},
      rating: '30A',
      voltage: 600,
      fusible: false,
      necLabel: 'PV SYSTEM DISCONNECT',
      location: 'Near Inverter'
    };
  }

  /**
   * Create inverter component
   */
  private static createInverter(solarLoad: any, yPosition: number): SLDInverter {
    return {
      id: this.generateId(),
      type: 'inverter',
      name: 'Solar Inverter',
      position: { x: 350, y: yPosition },
      size: { width: 80, height: 60 },
      rotation: 0,
      labels: [],
      necLabels: [`${solarLoad.kw}kW INVERTER`],
      specifications: {
        power: solarLoad.kw * 1000
      },
      inverterType: 'string',
      manufacturer: 'SolarEdge',
      model: 'SE7600H',
      acOutputKW: solarLoad.kw,
      dcInputVoltage: 600,
      acOutputVoltage: 240,
      efficiency: 0.97,
      mpptChannels: 2
    };
  }

  /**
   * Create AC disconnect component
   */
  private static createACDisconnect(yPosition: number): SLDDisconnect {
    return {
      id: this.generateId(),
      type: 'ac_disconnect',
      name: 'AC Disconnect',
      position: { x: 480, y: yPosition },
      size: { width: 60, height: 40 },
      rotation: 0,
      labels: [],
      necLabels: ['AC DISCONNECT'],
      specifications: {},
      rating: '60A',
      voltage: 240,
      fusible: false,
      necLabel: 'AC DISCONNECT',
      location: 'Near Main Panel'
    };
  }

  /**
   * Create battery component
   */
  private static createBattery(batteryLoad: any, yPosition: number): SLDBattery {
    return {
      id: this.generateId(),
      type: 'battery',
      name: 'Battery Storage',
      position: { x: 700, y: yPosition },
      size: { width: 100, height: 80 },
      rotation: 0,
      labels: [],
      necLabels: [`${batteryLoad.kw}kW / ${Math.round(batteryLoad.kw * 4)}kWh BATTERY`],
      specifications: {
        power: batteryLoad.kw * 1000,
        capacity: batteryLoad.kw * 4 * 1000 // Assume 4 hour capacity
      },
      batteryType: 'generic_ac',
      manufacturer: 'Generic',
      model: 'Battery System',
      capacityKWh: batteryLoad.kw * 4,
      powerKW: batteryLoad.kw,
      voltage: 240,
      coupling: 'ac',
      backupCapable: true,
      rapidShutdown: true
    };
  }

  /**
   * Create EVSE charger component
   */
  private static createEVSECharger(evseLoad: any, yPosition: number): SLDEVSECharger {
    return {
      id: this.generateId(),
      type: 'evse_charger',
      name: 'EV Charger',
      position: { x: 400, y: yPosition },
      size: { width: 80, height: 60 },
      rotation: 0,
      labels: [],
      necLabels: [`${evseLoad.amps}A EV CHARGER`],
      specifications: {
        amps: evseLoad.amps,
        power: evseLoad.va
      },
      manufacturer: 'Generic',
      model: 'Level 2 EVSE',
      powerKW: evseLoad.va / 1000,
      voltage: 240,
      current: evseLoad.amps,
      level: 2,
      circuitBreaker: `${evseLoad.amps}A`,
      dedicatedCircuit: true,
      necCompliant: true
    };
  }

  /**
   * Create grounding electrode component
   */
  private static createGroundingElectrode(yPosition: number): SLDGroundingElectrode {
    return {
      id: this.generateId(),
      type: 'grounding_electrode',
      name: 'Grounding Electrode',
      position: { x: 600, y: yPosition + 100 },
      size: { width: 40, height: 40 },
      rotation: 0,
      labels: [],
      necLabels: ['GROUNDING ELECTRODE'],
      specifications: {},
      electrodeType: 'rod',
      conductorSize: '#6 AWG',
      bondingJumper: '#6 AWG'
    };
  }

  /**
   * Generate connections between components
   */
  private static generateConnections(diagram: SLDDiagram): void {
    const components = diagram.components;
    
    // Find components by type
    const pvArrays = components.filter(c => c.type === 'pv_array');
    const dcDisconnects = components.filter(c => c.type === 'dc_disconnect');
    const inverters = components.filter(c => c.type === 'inverter');
    const acDisconnects = components.filter(c => c.type === 'ac_disconnect');
    const mainPanel = components.find(c => c.type === 'main_panel');
    const grid = components.find(c => c.type === 'grid');
    const batteries = components.filter(c => c.type === 'battery');
    const evseChargers = components.filter(c => c.type === 'evse_charger');
    const grounding = components.find(c => c.type === 'grounding_electrode');

    // Solar system connections
    pvArrays.forEach((pvArray, index) => {
      if (dcDisconnects[index]) {
        diagram.connections.push(this.createConnection(
          pvArray.id, dcDisconnects[index].id, 'dc', 'PV Output', '480V DC'
        ));
      }
      
      if (inverters[index] && dcDisconnects[index]) {
        diagram.connections.push(this.createConnection(
          dcDisconnects[index].id, inverters[index].id, 'dc', 'DC Input'
        ));
      }
      
      if (acDisconnects[index] && inverters[index]) {
        diagram.connections.push(this.createConnection(
          inverters[index].id, acDisconnects[index].id, 'ac', 'AC Output', '240V AC'
        ));
      }
      
      if (mainPanel && acDisconnects[index]) {
        diagram.connections.push(this.createConnection(
          acDisconnects[index].id, mainPanel.id, 'ac', 'Solar Input'
        ));
      }
    });

    // Main panel to grid
    if (mainPanel && grid) {
      diagram.connections.push(this.createConnection(
        mainPanel.id, grid.id, 'ac', 'Service Feed', '240V AC'
      ));
    }

    // Battery connections (AC-coupled)
    batteries.forEach(battery => {
      if (mainPanel) {
        diagram.connections.push(this.createConnection(
          battery.id, mainPanel.id, 'ac', 'Battery AC', '240V AC'
        ));
      }
    });

    // EVSE connections
    evseChargers.forEach(evse => {
      if (mainPanel) {
        diagram.connections.push(this.createConnection(
          mainPanel.id, evse.id, 'ac', 'EV Circuit', '240V AC'
        ));
      }
    });

    // Grounding connections
    if (grounding && mainPanel) {
      diagram.connections.push(this.createConnection(
        mainPanel.id, grounding.id, 'ground', 'Equipment Ground'
      ));
    }
  }

  /**
   * Create a connection between components
   */
  private static createConnection(
    fromId: string, 
    toId: string, 
    wireType: 'dc' | 'ac' | 'ground',
    label?: string,
    voltage?: string
  ): SLDConnection {
    return {
      id: this.generateId(),
      fromComponentId: fromId,
      toComponentId: toId,
      fromPort: 'output',
      toPort: 'input',
      wireType,
      label: label || '',
      voltage: voltage ? parseInt(voltage) : undefined
    };
  }

  /**
   * Add NEC-required labels to diagram
   */
  private static addNECLabels(diagram: SLDDiagram): void {
    diagram.components.forEach(component => {
      const requirements = this.necRequirements.filter(req => 
        req.componentTypes.includes(component.type)
      );
      
      requirements.forEach(req => {
        const label: SLDLabel = {
          id: this.generateId(),
          text: req.labelText.replace('{voltage}', '600'), // Placeholder
          position: { 
            x: component.position.x, 
            y: component.position.y - 30 
          },
          fontSize: 10,
          fontWeight: 'bold',
          color: '#000000',
          necRequired: true,
          necReference: req.article
        };
        
        diagram.labels.push(label);
        diagram.requiredLabels.push(label);
      });
    });
  }

  /**
   * Validate NEC compliance
   */
  private static validateNECCompliance(diagram: SLDDiagram): void {
    const violations: string[] = [];
    
    // Check for required disconnects
    const hasMainPanel = diagram.components.some(c => c.type === 'main_panel');
    const hasPVArray = diagram.components.some(c => c.type === 'pv_array');
    const hasDCDisconnect = diagram.components.some(c => c.type === 'dc_disconnect');
    const hasACDisconnect = diagram.components.some(c => c.type === 'ac_disconnect');
    
    if (hasPVArray && !hasDCDisconnect) {
      violations.push('PV systems require DC disconnect per NEC 690.13');
    }
    
    if (hasPVArray && !hasACDisconnect) {
      violations.push('PV systems require AC disconnect per NEC 690.13');
    }
    
    if (!hasMainPanel) {
      violations.push('System requires main service panel');
    }
    
    // Check for grounding
    const hasGrounding = diagram.components.some(c => c.type === 'grounding_electrode');
    if (!hasGrounding) {
      violations.push('System requires grounding electrode per NEC 250.52');
    }
    
    diagram.necViolations = violations;
    diagram.necCompliant = violations.length === 0;
  }

  /**
   * Auto-layout components in a logical flow
   */
  private static autoLayoutComponents(diagram: SLDDiagram): void {
    // Simple left-to-right flow layout
    const componentOrder = [
      'pv_array', 'dc_disconnect', 'inverter', 'ac_disconnect', 
      'main_panel', 'grid', 'battery', 'evse_charger'
    ];
    
    let x = 50;
    const y = 200;
    const spacing = 150;
    
    componentOrder.forEach(type => {
      const components = diagram.components.filter(c => c.type === type);
      components.forEach((component, index) => {
        component.position.x = x;
        component.position.y = y + (index * 100);
      });
      if (components.length > 0) {
        x += spacing;
      }
    });
    
    // Position grounding electrode below main panel
    const grounding = diagram.components.find(c => c.type === 'grounding_electrode');
    const mainPanel = diagram.components.find(c => c.type === 'main_panel');
    if (grounding && mainPanel) {
      grounding.position.x = mainPanel.position.x;
      grounding.position.y = mainPanel.position.y + 150;
    }
  }

  /**
   * Determine system type from load data
   */
  private static determineSystemType(loadState: LoadState): 'grid_tied' | 'grid_tied_with_battery' | 'off_grid' {
    const hasSolar = loadState.solarBatteryLoads.some(load => 
      load.type === 'solar' && load.quantity > 0
    );
    const hasBattery = loadState.solarBatteryLoads.some(load => 
      load.type === 'battery' && load.quantity > 0
    );
    
    if (hasBattery) {
      return 'grid_tied_with_battery';
    } else if (hasSolar) {
      return 'grid_tied';
    } else {
      return 'grid_tied'; // Default
    }
  }

  /**
   * Get default configuration
   */
  private static getDefaultConfig(): SLDGenerationConfig {
    return {
      style: 'professional',
      includeSpecifications: true,
      includeNECLabels: true,
      autoLayout: true,
      componentSpacing: 150,
      lineStyle: 'solid',
      showGrounding: true,
      showConduitSizing: false,
      colorCoding: false
    };
  }

  /**
   * Generate unique ID
   */
  private static generateId(): string {
    return `sld_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
  }
}